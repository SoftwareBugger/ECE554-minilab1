

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Minilab1_proj(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output	reg	     [6:0]		HEX0,
	output	reg	     [6:0]		HEX1,
	output	reg	     [6:0]		HEX2,
	output	reg	     [6:0]		HEX3,
	output	reg	     [6:0]		HEX4,
	output	reg	     [6:0]		HEX5,
	
	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW
);

localparam DATA_WIDTH = 8;
localparam DEPTH = 8;


parameter HEX_0 = 7'b1000000;		// zero
parameter HEX_1 = 7'b1111001;		// one
parameter HEX_2 = 7'b0100100;		// two
parameter HEX_3 = 7'b0110000;		// three
parameter HEX_4 = 7'b0011001;		// four
parameter HEX_5 = 7'b0010010;		// five
parameter HEX_6 = 7'b0000010;		// six
parameter HEX_7 = 7'b1111000;		// seven
parameter HEX_8 = 7'b0000000;		// eight
parameter HEX_9 = 7'b0011000;		// nine
parameter HEX_10 = 7'b0001000;	// ten
parameter HEX_11 = 7'b0000011;	// eleven
parameter HEX_12 = 7'b1000110;	// twelve
parameter HEX_13 = 7'b0100001;	// thirteen
parameter HEX_14 = 7'b0000110;	// fourteen
parameter HEX_15 = 7'b0001110;	// fifteen
parameter OFF   = 7'b1111111;		// all off

//=======================================================
//  REG/WIRE declarations
//=======================================================

logic [7:0] A [7:0];
logic [7:0] B;
logic En;
logic [8:0] FIFO_rden;
logic [23:0] set_C [7:0];
logic [23:0] C [7:0];

// FIFO signasls
logic [8:0] wren;
logic [7:0] AnB_in;
logic [8:0] full;
logic [8:0] empty;

// Set En when all fifos are full
assign En = &full;
logic filler_done;

logic filler_write;
logic[31:0] address;
logic start_filler;
logic filler_en;
logic [3:0] cnt;
logic [2:0] c_sel;

logic rst_n, start, done, Clr;
logic key1_prev;


//=======================================================
//  Module instantiation
//=======================================================

fifo_filler filler
(
	.clk(CLOCK_50),
	.rst_n(rst_n),
	.start(filler_en),
	.fifo_full(full[cnt]),
	.address(address),
	.wren(filler_write),
	.done(filler_done),
	.data_o(AnB_in)
);

Multiplication multiply
(
	.A(A),
	.B(B),
	.En(En),
	.Clr(Clr),
	.clk(CLOCK_50),
	.rst_n(rst_n),
	.FIFO_empty(empty),
	.done(done),
	.FIFO_rden(FIFO_rden),
	.C(set_C)
);

FIFO
#(
.DEPTH(DEPTH),
.DATA_WIDTH(DATA_WIDTH)
) input_fifo [8:0]
(
.clk(CLOCK_50),
.rst_n(rst_n),
.rden(FIFO_rden),
.wren(wren),
.i_data(AnB_in),
.o_data({A[7], A[6], A[5], A[4], A[3], A[2], A[1], A[0], B}),
.full(full),
.empty(empty)
);

//=======================================================
//  Structural coding
//=======================================================

assign rst_n = KEY[0];

assign c_sel = {SW[3], SW[2], SW[1]};
assign Clr = ~KEY[2];

always_ff @(posedge CLOCK_50)
	key1_prev = KEY[1];
	
assign start = KEY[1] & ~key1_prev;

typedef enum reg[1:0]{IDLE, FILL, MULTI, DONE}state_t;
state_t state, nxt_state;
always_ff@(posedge CLOCK_50, negedge rst_n)begin
	if(!rst_n)
		state <= IDLE;
	else
		state <= nxt_state;
end



logic clr_cnt;
logic inc_cnt;

assign address = cnt;
assign wren = filler_write << address;
assign C = set_C;

always_ff @(negedge rst_n, posedge CLOCK_50) begin
	if (!rst_n) begin
		cnt <= 0;
	end
	else if (clr_cnt) begin
		cnt <= 0;
	end
	else if (inc_cnt) begin
		cnt <= cnt + 1;
	end
end


always_ff @(negedge rst_n, posedge CLOCK_50) begin
	if (!rst_n) filler_en <= 0;
	else filler_en <= start_filler;
end

always_comb begin
	nxt_state = state;
	clr_cnt = 0;
	start_filler = 0;
	inc_cnt = 0;
	case(state)
		IDLE:begin
			if (start) begin
				clr_cnt = 1;
				start_filler = 1;
				nxt_state = FILL;
			end
		end
		FILL:begin
			if (full[cnt]) begin
				if (cnt != 8) begin
					inc_cnt = 1;
					start_filler = 1;
				end
				else begin
					nxt_state = MULTI;
				end
			end
		end
		MULTI: begin
			if (done) nxt_state = IDLE;
		end
		
	endcase
end


always @(*) begin
  if (state == IDLE & SW[0]) begin
    case(set_C[c_sel][3:0])
      4'd0: HEX0 = HEX_0;
	   4'd1: HEX0 = HEX_1;
	   4'd2: HEX0 = HEX_2;
	   4'd3: HEX0 = HEX_3;
	   4'd4: HEX0 = HEX_4;
	   4'd5: HEX0 = HEX_5;
	   4'd6: HEX0 = HEX_6;
	   4'd7: HEX0 = HEX_7;
	   4'd8: HEX0 = HEX_8;
	   4'd9: HEX0 = HEX_9;
	   4'd10: HEX0 = HEX_10;
	   4'd11: HEX0 = HEX_11;
	   4'd12: HEX0 = HEX_12;
	   4'd13: HEX0 = HEX_13;
	   4'd14: HEX0 = HEX_14;
	   4'd15: HEX0 = HEX_15;
    endcase
  end
  else begin
    HEX0 = OFF;
  end
end

always @(*) begin
  if (state == IDLE & SW[0]) begin
    case(set_C[c_sel][7:4])
      4'd0: HEX1 = HEX_0;
	   4'd1: HEX1 = HEX_1;
	   4'd2: HEX1 = HEX_2;
	   4'd3: HEX1 = HEX_3;
	   4'd4: HEX1 = HEX_4;
	   4'd5: HEX1 = HEX_5;
	   4'd6: HEX1 = HEX_6;
	   4'd7: HEX1 = HEX_7;
	   4'd8: HEX1 = HEX_8;
	   4'd9: HEX1 = HEX_9;
	   4'd10: HEX1 = HEX_10;
	   4'd11: HEX1 = HEX_11;
	   4'd12: HEX1 = HEX_12;
	   4'd13: HEX1 = HEX_13;
	   4'd14: HEX1 = HEX_14;
	   4'd15: HEX1 = HEX_15;
    endcase
  end
  else begin
    HEX1 = OFF;
  end
end

always @(*) begin
  if (state == IDLE & SW[0]) begin
    case(set_C[c_sel][11:8])
      4'd0: HEX2 = HEX_0;
	   4'd1: HEX2 = HEX_1;
	   4'd2: HEX2 = HEX_2;
	   4'd3: HEX2 = HEX_3;
	   4'd4: HEX2 = HEX_4;
	   4'd5: HEX2 = HEX_5;
	   4'd6: HEX2 = HEX_6;
	   4'd7: HEX2 = HEX_7;
	   4'd8: HEX2 = HEX_8;
	   4'd9: HEX2 = HEX_9;
	   4'd10: HEX2 = HEX_10;
	   4'd11: HEX2 = HEX_11;
	   4'd12: HEX2 = HEX_12;
	   4'd13: HEX2 = HEX_13;
	   4'd14: HEX2 = HEX_14;
	   4'd15: HEX2 = HEX_15;
    endcase
  end
  else begin
    HEX2 = OFF;
  end
end

always @(*) begin
  if (state == IDLE & SW[0]) begin
    case(set_C[c_sel][15:12])
      4'd0: HEX3 = HEX_0;
	   4'd1: HEX3 = HEX_1;
	   4'd2: HEX3 = HEX_2;
	   4'd3: HEX3 = HEX_3;
	   4'd4: HEX3 = HEX_4;
	   4'd5: HEX3 = HEX_5;
	   4'd6: HEX3 = HEX_6;
	   4'd7: HEX3 = HEX_7;
	   4'd8: HEX3 = HEX_8;
	   4'd9: HEX3 = HEX_9;
	   4'd10: HEX3 = HEX_10;
	   4'd11: HEX3 = HEX_11;
	   4'd12: HEX3 = HEX_12;
	   4'd13: HEX3 = HEX_13;
	   4'd14: HEX3 = HEX_14;
	   4'd15: HEX3 = HEX_15;
    endcase
  end
  else begin
    HEX3 = OFF;
  end
end

always @(*) begin
  if (state == IDLE & SW[0]) begin
    case(set_C[c_sel][19:16])
      4'd0: HEX4 = HEX_0;
	   4'd1: HEX4 = HEX_1;
	   4'd2: HEX4 = HEX_2;
	   4'd3: HEX4 = HEX_3;
	   4'd4: HEX4 = HEX_4;
	   4'd5: HEX4 = HEX_5;
	   4'd6: HEX4 = HEX_6;
	   4'd7: HEX4 = HEX_7;
	   4'd8: HEX4 = HEX_8;
	   4'd9: HEX4 = HEX_9;
	   4'd10: HEX4 = HEX_10;
	   4'd11: HEX4 = HEX_11;
	   4'd12: HEX4 = HEX_12;
	   4'd13: HEX4 = HEX_13;
	   4'd14: HEX4 = HEX_14;
	   4'd15: HEX4 = HEX_15;
    endcase
  end
  else begin
    HEX4 = OFF;
  end
end

always @(*) begin
  if (state == IDLE & SW[0]) begin
    case(set_C[c_sel][23:20])
      4'd0: HEX5 = HEX_0;
	   4'd1: HEX5 = HEX_1;
	   4'd2: HEX5 = HEX_2;
	   4'd3: HEX5 = HEX_3;
	   4'd4: HEX5 = HEX_4;
	   4'd5: HEX5 = HEX_5;
	   4'd6: HEX5 = HEX_6;
	   4'd7: HEX5 = HEX_7;
	   4'd8: HEX5 = HEX_8;
	   4'd9: HEX5 = HEX_9;
	   4'd10: HEX5 = HEX_10;
	   4'd11: HEX5 = HEX_11;
	   4'd12: HEX5 = HEX_12;
	   4'd13: HEX5 = HEX_13;
	   4'd14: HEX5 = HEX_14;
	   4'd15: HEX5 = HEX_15;
    endcase
  end
  else begin
    HEX5 = OFF;
  end
end

assign LEDR = {{8{1'b0}}, state};
endmodule
